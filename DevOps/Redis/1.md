# Redis Nedir?

Redis (Remote Dictionary Server), aÃ§Ä±k kaynak kodlu, **in-memory** veri saklama sistemidir. Ana amacÄ± yÃ¼ksek performanslÄ± veri eriÅŸimi saÄŸlamaktadÄ±r. Redis; string, list, set, sorted set, hash, bitmap ve hyperloglog gibi zengin veri yapÄ±larÄ±nÄ± destekler. Genellikle veri caching amacÄ±yla kullanÄ±lÄ±r. AynÄ± zamanda mesaj kuyruÄŸu, gerÃ§ek zamanlÄ± analizi veya geÃ§ici veri saklama gibi birÃ§ok farklÄ± senaryoda tercih edilir.

![Redis](./img/Redis.png)

Redisâ€™in Temel Ã–zellikleri;

* **ğŸ§  Bellek Ä°Ã§i Ã‡alÄ±ÅŸma:** Verileri RAM'de tutulur, bu da onu son derece hÄ±zlÄ± yapar.
* **ğŸ” KalÄ±cÄ± Saklama (Persistence):** Dilerseniz verilerinizi disk Ã¼zerinde de saklayabilirsiniz.
* **ğŸ“¦ Zengin Veri YapÄ±larÄ±:** Listeler, kÃ¼meler, hashâ€™ler, sÄ±ralÄ± kÃ¼meler ve daha fazlasÄ±.
* **ğŸ”„ YÃ¼ksek PerformanslÄ± Replikasyon:** Master-slave mimarisiyle veri Ã§oÄŸaltma mÃ¼mkÃ¼ndÃ¼r.
* **ğŸ“¡ Pub/Sub DesteÄŸi:** GerÃ§ek zamanlÄ± mesajlaÅŸma altyapÄ±larÄ± iÃ§in idealdir.
* **ğŸ” Atomic Ä°ÅŸlemler:** Birden fazla iÅŸlemi tek seferde, tutarlÄ± biÃ§imde gerÃ§ekleÅŸtirebilirsiniz.
* **âš™ï¸ Lua Script DesteÄŸi:** GeliÅŸmiÅŸ iÅŸ kurallarÄ± iÃ§in script Ã§alÄ±ÅŸtÄ±rma imkanÄ± sunar.

Redisin birÃ§ok farklÄ± kullanÄ±m alanlarÄ± bulunmaktadÄ±r;

* **Ã–nbellekleme (Caching):** Redis'in en yaygÄ±n kullanÄ±m alanÄ± olarak veritabanÄ± sorgularÄ±nÄ± veya API yanÄ±tlarÄ±nÄ± Ã¶nbelleÄŸi almak iÃ§in kullanÄ±lÄ±r.
* **Mesaj KuyruklarÄ± ve GÃ¶rev SÄ±ralama** Redis, BRPOP, LPUSH gibi komutlarla kuyruk mantÄ±ÄŸÄ±na uygun Ã§alÄ±ÅŸabilir. Bu da onu bir mesaj aracÄ± gibi kullanmayÄ± mÃ¼mkÃ¼n kÄ±lar.
* **GerÃ§ek ZamanlÄ± Analiz** KullanÄ±cÄ± sayacÄ±, tÄ±klama takibi, oyun puanlarÄ± gibi verilerin iÅŸlenmesinde Redis bÃ¼yÃ¼k bir avantaj saÄŸlar.
* **Oturum YÃ¶netimi** Redis, kullanÄ±cÄ± oturumlarÄ±nÄ±n hÄ±zlÄ± bir ÅŸekilde tutulup kontrol edilmesinde ideal bir Ã§Ã¶zÃ¼mdÃ¼r.
* **Liderlik Tespiti / Kilitleme MekanizmalarÄ±** Distributed locking gibi mekanizmalar Redisâ€™in atomik iÅŸlem yapabilme yeteneÄŸi sayesinde uygulanabilir.

## Senaryo 1 - Cache API Performans Testi

Bu senaryonun temel hedefi aÅŸaÄŸÄ±daki gibidir;

* âœ… **API performansÄ±nÄ± artÄ±rmak** iÃ§in Redis cache kullanmak
* âœ… AynÄ± veriyi tekrar tekrar veritabanÄ±ndan sorgulamak yerine **cacheâ€™den hÄ±zlÄ±ca sunmak**
* âœ… **Fallback (yedek)** mantÄ±ÄŸÄ±yla: eÄŸer veri Redis'te yoksa PostgreSQL'den alÄ±nsÄ±n ve Redis'e yazÄ±lsÄ±n
* âœ… Cache sÃ¼resi dolunca veri **yeniden gÃ¼ncellenerek** kullanÄ±cÄ±ya sunulsun
* âœ… Her iki yÃ¶ntemin (Redis ve DB) performans farkÄ±nÄ± Ã¶lÃ§erek **gerÃ§ekÃ§i sonuÃ§lar elde etmek**

KullanÄ±lan teknolojiler ve amaÃ§larÄ± aÅŸaÄŸÄ±daki gibidir;

| Teknoloji          | AmaÃ§                                 |
| ------------------ | ------------------------------------ |
| **FastAPI**        | REST API ve endpoint'leri oluÅŸturmak |
| **Redis**          | HÄ±zlÄ± veri cache (geÃ§ici bellek)     |
| **PostgreSQL**     | KalÄ±cÄ± veritabanÄ± (makaleler)        |
| **Docker Compose** | TÃ¼m sistemi tek komutla baÅŸlatmak    |


**KlasÃ¶r YapÄ±sÄ±**

```bash
redis-cache-test/
â”œâ”€â”€ app/
â”‚   â”œâ”€â”€ __init__.py              # Python modÃ¼lÃ¼
â”‚   â”œâ”€â”€ main.py                  # FastAPI uygulamasÄ±
â”‚   â”œâ”€â”€ database.py              # SQLAlchemy veritabanÄ± baÄŸlantÄ±sÄ±
â”‚   â”œâ”€â”€ models.py                # SQLAlchemy modelleri (Article tablosu)
â”œâ”€â”€ Dockerfile                   # FastAPI Docker tanÄ±mÄ±
â”œâ”€â”€ docker-compose.yml           # Redis, PostgreSQL ve FastAPI bileÅŸenlerini birleÅŸtirir
â”œâ”€â”€ requirements.txt             # Python baÄŸÄ±mlÄ±lÄ±klarÄ±
â”œâ”€â”€ create_tables.py             # Article tablosunu oluÅŸturur
â””â”€â”€ test_perf.py                 # Performans testi scripti (Redis vs DB)
```

**app/database.py**

```python
# SQLAlchemy iÃ§in veritabanÄ± baÄŸlantÄ±sÄ± ayarlarÄ±

from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, declarative_base

# PostgreSQL baÄŸlantÄ± URI
DATABASE_URL = "postgresql://user:pass@postgres:5432/testdb"

# VeritabanÄ± motoru ve session yapÄ±sÄ±
engine = create_engine(DATABASE_URL)
SessionLocal = sessionmaker(bind=engine, autoflush=False, autocommit=False)

# Model sÄ±nÄ±flarÄ± bu base'den tÃ¼reyecek
Base = declarative_base()

```

**app/models.py**

```python
# Article modelini tanÄ±mlar

from sqlalchemy import Column, Integer, String
from app.database import Base

class Article(Base):
    __tablename__ = "articles"

    id = Column(Integer, primary_key=True, index=True)
    title = Column(String)
    view_count = Column(Integer)

```

**app/main.py**

```python
# FastAPI uygulamasÄ± â€“ 2 endpoint: biri Redis cache'li, biri doÄŸrudan veritabanÄ±

from fastapi import FastAPI
from sqlalchemy.orm import Session
from app.database import SessionLocal
from app.models import Article
import redis, json, time

app = FastAPI()

# Redis baÄŸlantÄ±sÄ±
r = redis.Redis(host="redis", port=6379, db=0)

@app.get("/popular-articles-cache")
def get_articles_cache():
    start = time.time()
    key = "popular_articles"

    # Redis'ten kontrol et
    cached_data = r.get(key)
    if cached_data:
        duration = time.time() - start
        return {"source": "redis", "duration_ms": round(duration * 1000, 2), "data": json.loads(cached_data)}

    # Yoksa DB'den al ve Redis'e yaz
    db: Session = SessionLocal()
    articles = db.query(Article).order_by(Article.view_count.desc()).limit(5).all()
    result = [{"id": a.id, "title": a.title, "view_count": a.view_count} for a in articles]
    r.setex(key, 300, json.dumps(result))  # 5 dakika cache sÃ¼resi

    duration = time.time() - start
    return {"source": "db_to_redis", "duration_ms": round(duration * 1000, 2), "data": result}

@app.get("/popular-articles-db")
def get_articles_db():
    start = time.time()

    # DoÄŸrudan veritabanÄ±ndan ver
    db: Session = SessionLocal()
    articles = db.query(Article).order_by(Article.view_count.desc()).limit(5).all()
    result = [{"id": a.id, "title": a.title, "view_count": a.view_count} for a in articles]

    duration = time.time() - start
    return {"source": "db_direct", "duration_ms": round(duration * 1000, 2), "data": result}
```

**create_tables.py**

```python
# Article tablosunu veritabanÄ±nda oluÅŸturur

from app.database import engine
from app.models import Base

Base.metadata.create_all(bind=engine)

```

**test_perf.py**

```python
# API endpoint'lerinin ortalama yanÄ±t sÃ¼resini Ã¶lÃ§er

import requests
import time

def test_endpoint(name, url, repeat=100):
    print(f"\nğŸ” Testing: {name}")
    durations = []

    for _ in range(repeat):
        start = time.time()
        res = requests.get(url)
        durations.append(time.time() - start)

    avg = round(sum(durations) / repeat * 1000, 2)
    print(f"âœ… Average response time: {avg} ms")

BASE = "http://localhost:8000"

test_endpoint("Redis Cache", f"{BASE}/popular-articles-cache")
test_endpoint("Direct DB", f"{BASE}/popular-articles-db")

```

**docker-compose.yml**

```yml
version: '3.8'

services:
  redis:
    image: redis:latest
    container_name: redis_server
    ports:
      - "6379:6379"

  postgres:
    image: postgres:15
    container_name: postgres_db
    environment:
      POSTGRES_USER: user
      POSTGRES_PASSWORD: pass
      POSTGRES_DB: testdb
    ports:
      - "5432:5432"
    volumes:
      - pgdata:/var/lib/postgresql/data

  fastapi:
    build: .
    container_name: fastapi_app
    ports:
      - "8000:8000"
    volumes:
      - ./app:/app
    depends_on:
      - redis
      - postgres

volumes:
  pgdata:

```

Sistemin Ã§alÄ±ÅŸtÄ±rÄ±lmasÄ± amacÄ±yla ``docker-compose up --build`` komutu kullanÄ±lÄ±r.


![Redis](./img/1.png)

KullanÄ±lacak olan toplanÄ±n oluÅŸturulmasÄ± amacÄ±yla ``docker exec -it fastapi_app python /app/create_tables.py`` komutu kullanÄ±lÄ±r.
Tablo oluÅŸturulduktan sonra yeni verilerin eklenmesi amacÄ±yla ``docker exec -it postgres_db psql -U user -d testdb`` komtundan sonra ``INSERT INTO articles (title, view_count) VALUES ('Makale 1', 120), ('Makale 2', 150), ('Makale 3', 90),('Makale 4', 300), ('Makale 5', 200);`` SQL komutu kullanÄ±lÄ±r.

![Redis](./img/2.png)

Testin baÅŸlatÄ±lmasÄ± amacÄ±yla ``python test_perf.py`` komutu kullanÄ±lmaktadÄ±r. 

![Redis](./img/3.png)

GÃ¶rselde gÃ¶rÃ¼ldÃ¼ÄŸÃ¼ gibi Redis kullanÄ±mÄ± sayesinde API'nin yanÄ±t sÃ¼resi yaklaÅŸÄ±k 20 kat daha hÄ±zlÄ± hale gelmiÅŸtir.
Bu, Ã¶zellikle yÃ¼ksek trafikli ve sÄ±k tekrar eden veri isteklerinde Redisâ€™in API performansÄ± Ã¼zerindeki etkisini aÃ§Ä±kÃ§a gÃ¶stermektedir.
