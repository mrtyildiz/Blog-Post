# 📌 DevOps ve Güvenlik

Yazılım geliştirme süreçlerinde, güvenlik önemli bir kriterdir. DevOps süreçleri/Kültürü, yazılım geliştirme ve operasyonel ekiplerinin bir araya getirerek yazılım süreçlerinin hızlandırmaktadır. Ancak artan siber güvenlik zafiyetleri/saldırıları, DevSecOps yaklaşımını gündeme taşımıştır. DevSecOps, güvenliğin en başından itibaren dail edilmesi anlamına gelmektedir.

![](/img/SecOps.jpg)

Kritik altyapılara yönelik siber güvenlik saldırıları sıradan hale geldi. Bir güvenlik açığı bile milyonlarca kullanıcıyı ektileyebilir. Örneğin, yanlış yapılandırılmış bir API, kullanıcı verilerinin çalınmasına yol açabilir. Bu nedenle şirkeler sadece “daha hızlı geliştirmek” yerine artık “daha güvenli geliştirmeye” odaklanmaktadır.

**Neden DevSecOps?**

Geleneksel yazılım geliştirme modelinde güvenlik, yazılım sürüm çıkılmadan hemen önce devreye girmektedir. Bu durum güvenlik açıklarının geç fark edilmesine ve maliyetlerin artmasına yol açmaktadır. DevSecOps yaklaşımıyla;

* Kod geliştirme aşamasında güvenlik kontrolleri yapılır.
* CI/CD pipeline içine otomatik güvenlik taramaları entegre edilir.
* Hatalar hızlı geri bildirimle düzeltilir.

**🔹 Golang örneği – kötü uygulama:**


```go
// Hassas veriyi loglamak -> kötü uygulama
log.Printf("User login attempt with password: %s", password)
```
**🔹 Doğru uygulama:**
```golang
// Güvenli loglama -> hassas veri yazılmaz
log.Println("User login attempt detected")
```
Bu tarz kontroller otomatik CI/CD sürecinde yakalanabilir.

----------------------------------------------------------------------------------------------------

## API Güvenliği

API'ler, modern yazılım geliştirme süreçlerinden önemli bir yapı taşıdır. Basit bir login endpoint düşünelim;
```go
// ❌ Kimlik doğrulama ve rate limit yok
r.POST("/login", func(c *gin.Context) {
    var creds Credentials
    if err := c.BindJSON(&creds); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": "invalid request"})
        return
    }
    c.JSON(http.StatusOK, gin.H{"status": "login success"})
})
```
Bu endpoint saldırıya açıktır. DevSecOps yaklaşımıyla şunlar yapılabilir;

✅ JWT tabanlı kimlik doğrulama
✅ Rate limiting ile brute-force engelleme
✅ Input validation

Bu işlemler için aşağıdaki gibi örnek kod blogları kullanılabilir;

**Input Validation**
```go
type LoginReq struct {
    Email    string `json:"email" binding:"required,email"`
    Password string `json:"password" binding:"required,min=8"`
}

r.POST("/login", func(c *gin.Context) {
    var req LoginReq
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": "invalid input"})
        return
    }
    c.JSON(http.StatusOK, gin.H{"status": "valid input"})
})

```
Bu örnekte ``binding:"required,email"`` gibi tag’ler ile zorunluluk ve format kontrolü yapıyoruz.

**JWT Kimlik Doğrulama**
```go
import "github.com/golang-jwt/jwt/v5"

secret := []byte("mysecret")

r.POST("/login", func(c *gin.Context) {
    // normalde burada kullanıcı doğrulama yapılır
    token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{
        "sub": "user123",
        "exp": time.Now().Add(15 * time.Minute).Unix(),
    })
    signed, _ := token.SignedString(secret)
    c.JSON(200, gin.H{"token": signed})
})

auth := r.Group("/api")
auth.Use(func(c *gin.Context) {
    t := c.GetHeader("Authorization")[7:]
    parsed, _ := jwt.Parse(t, func(*jwt.Token) (interface{}, error) {
        return secret, nil
    })
    if parsed == nil || !parsed.Valid {
        c.AbortWithStatusJSON(401, gin.H{"error": "invalid token"})
        return
    }
    c.Next()
})

auth.GET("/profile", func(c *gin.Context) {
    c.JSON(200, gin.H{"message": "protected ok"})
})
```
``/login`` endpoint’inde JWT üret, ``Authorization: Bearer <token>`` ile istek gönderildiğinde middleware doğrular.

**Rate Limiting**

```go
import "golang.org/x/time/rate"

limiter := rate.NewLimiter(1, 3) // saniyede 1 istek, burst=3

r.Use(func(c *gin.Context) {
    if !limiter.Allow() {
        c.AbortWithStatusJSON(429, gin.H{"error": "too many requests"})
        return
    }
    c.Next()
})
```
Aynı anda en fazla 3 burst, ardından saniyede 1 istek izin veriliyor.


Örnek rate limiting middleware:
```go
import "golang.org/x/time/rate"

limiter := rate.NewLimiter(1, 3) // saniyede 1 istek, burst=3
r.Use(func(c *gin.Context) {
    if !limiter.Allow() {
        c.AbortWithStatusJSON(http.StatusTooManyRequests, gin.H{"error": "too many requests"})
        return
    }
    c.Next()
})
```

## CI/CD Pipeline + Go Uygulamaları + Güvenlik Taraması

DevSecOps mantığı CI/CD süreçlerine entegtre edilebilir. Entegre işlemleri aşağıdaki adımlar izlenir;

1. Kodun alınması (checkout)
2. Go build ve test çalıştırma
3. Statik güvenlik taraması (gosec)
4. Container image oluşturma
5. Container image üzerinde güvenlik taraması (Trivy gibi)
6. Deployment

**🔹 GitHub Actions örneği:**

```yaml
name: Go CI/CD with Security

on: [push, pull_request]

jobs:
  build-and-scan:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.22'

      - name: Build
        run: go build ./...

      - name: Run tests
        run: go test ./...

      - name: Run gosec (Static Security Analysis)
        run: go install github.com/securego/gosec/v2/cmd/gosec@latest && gosec ./...

      - name: Build Docker image
        run: docker build -t myapp:latest .

      - name: Trivy Scan (Docker Image Security)
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: 'myapp:latest'
          format: 'table'

```
Bu pipeline’da:

* gosec → Golang kodunda güvenlik açıklarını analiz eder.
* Trivy → Docker imajındaki zafiyetleri tarar.
* Testler → Hem fonksiyonel hem de güvenlik kontrollerinin sürekliliğini sağlar.

Sonuçta yazılım sadece hızlı değil, aynı zamanda güvenli bir şekilde devreye alınır.
